{
  "prog": {
    "lm": null,
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "code": "# Write your solution here.\n\ndictionary={'!hello': bot_hello,'!shout': bot_shout,'!divide': bot_divide,'!count': bot_count,'!topic': bot_topic}\n\ndef dispatch_bot_command(name,payload):\n\n    if name in dictionary.keys():\n\n      a=dictionary[name]\n\n      a(payload)\n\n    else:\n\n      bot_say('Unknown command '+name)\n\n\n\n\n\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\n\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\n\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "answer_code": "BOT_COMMANDS = {\n    '!hello': bot_hello,\n    '!shout': bot_shout,\n    '!divide': bot_divide,\n    '!count': bot_count,\n    '!topic': bot_topic,\n}\n\ndef dispatch_bot_command(command, payload):\n    if command in BOT_COMMANDS:\n        function = BOT_COMMANDS[command]\n        function(payload)\n    else:\n        bot_say(f'Unknown command: {command}')\n\ndispatch_bot_command('!topic', ['5'])",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Function uses the dictionary to look up the function object associated with a command name",
        "rationale": "In this case, the code snippet correctly defines a dictionary associating command names with function objects and uses this dictionary to look up the function object associated with a command name. It then calls the function if it exists in the dictionary. The code snippet also handles the case where the command is not recognized by the bot. Overall, the code snippet addresses the subquestion aspect effectively.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "def bot_count(payload):\n\n    # Convert elements in the payload to appropriate types\n\n    start = 1 if len(payload) == 1 else int(payload[0])\n\n    count = int(payload[0]) if len(payload) == 1 else int(payload[1])\n\n\n\n    # Use a loop to repeatedly call bot_say()\n\n    for i in range(start, start + count):\n\n        # Display the current number using bot_say()\n\n        bot_say(i)\n\n\n\n# Test calls\n\nbot_count(['10', '3'])  #=> Chatbot: 10, Chatbot: 11, Chatbot: 12\n\nprint(\"NEXT\")\n\nbot_count(['2'])        #=> Chatbot: 1, Chatbot: 2\n\nprint(\"NEXT\")\n\nbot_count(['5'])        #=> Chatbot: 1, Chatbot: 2, Chatbot: 3, Chatbot: 4, Chatbot: 5\n\n\n",
        "answer_code": "def bot_count(payload):\n    if len(payload) == 1:\n        from_number = 1\n        stop = int(payload[0]) + from_number\n    else:\n        from_number = int(payload[0])\n        stop = int(payload[1]) + from_number\n    for i in range(from_number, stop):\n        bot_say(i)\n\nbot_count(['10', '3'])\nbot_count(['2'])",
        "question_text": "### Task 4: Chatbot !count command (12 marks)\n\nImplement the behaviour for a `!count` chatbot command. Like `!divide`, you may assume that the user always provides two numbers. However, in this case they will also be whole numbers. The first of these numbers represents the value to start counting from. The second number represents how many times to count. The bot always counts by ones in ascending order (e.g. 2, 3, 4, 5 when starting at 2 and counting 4 times).\n\nIf the payload contains only one number, that number represents how many times to count and the bot should count up from 1. I recommend solving the task without this feature first, and then adding it afterwards.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_count(['10', '3'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;11\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;12\n<\/font>\n\n```python\nbot_count(['2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;2\n<\/font>\n\n#### Criteria\n\n- Correct function definition. (2 marks)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Uses a loop to repeatedly call `bot_say()`. (2 marks)\n- The loop repeats the correct number of times. (2 marks)\n- The correct numbers are displayed, with one number per chatbot message. (2 marks)\n- The bot correctly counts up from one when only a single value is provided in the payload. (2 marks)",
        "subquestion": "The bot correctly counts up from one when only a single value is provided in the payload",
        "rationale": "produce the student_mark_out_of_10. We first check if the length of the payload is 1, if so, we set the starting number to 1. Then, we correctly calculate the count based on the payload. Next, we use a loop to call bot_say() the correct number of times starting from the correct number. Finally, we test the function with the provided examples and additional cases to ensure it counts up from 1 when only a single value is provided.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Write your bot_count() function here.\n\ndef bot_count(payload):\n\n  if len(payload) == 1:\n\n    start = 1\n\n    count = int(payload[0])\n\n  else:\n\n    start = int(payload[0])\n\n    count = int(payload[1])\n\n  for i in range(start, start + count):\n\n    bot_say(str(i))\n\n\n\n\n\nbot_count(['10', '3'])  #=> Chatbot: 10, Chatbot: 11, Chatbot: 12\n\nbot_count(['2'])        #=> Chatbot: 1, Chatbot: 2",
        "answer_code": "def bot_count(payload):\n    if len(payload) == 1:\n        from_number = 1\n        stop = int(payload[0]) + from_number\n    else:\n        from_number = int(payload[0])\n        stop = int(payload[1]) + from_number\n    for i in range(from_number, stop):\n        bot_say(i)\n\nbot_count(['10', '3'])\nbot_count(['2'])",
        "question_text": "### Task 4: Chatbot !count command (12 marks)\n\nImplement the behaviour for a `!count` chatbot command. Like `!divide`, you may assume that the user always provides two numbers. However, in this case they will also be whole numbers. The first of these numbers represents the value to start counting from. The second number represents how many times to count. The bot always counts by ones in ascending order (e.g. 2, 3, 4, 5 when starting at 2 and counting 4 times).\n\nIf the payload contains only one number, that number represents how many times to count and the bot should count up from 1. I recommend solving the task without this feature first, and then adding it afterwards.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_count(['10', '3'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;11\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;12\n<\/font>\n\n```python\nbot_count(['2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;2\n<\/font>\n\n#### Criteria\n\n- Correct function definition. (2 marks)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Uses a loop to repeatedly call `bot_say()`. (2 marks)\n- The loop repeats the correct number of times. (2 marks)\n- The correct numbers are displayed, with one number per chatbot message. (2 marks)\n- The bot correctly counts up from one when only a single value is provided in the payload. (2 marks)",
        "subquestion": "The correct numbers are displayed, with one number per chatbot message",
        "rationale": "The code snippet correctly displays the correct numbers with one number per chatbot message. It iterates through the range of numbers and calls `bot_say()` for each number.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Write your solution here.\n\nCOMMANDS = {\n\n    '!hello': bot_hello,\n\n    '!shout': bot_shout,\n\n    '!divide': bot_divide,\n\n    '!count': bot_count,\n\n    '!topic': bot_topic\n\n}\n\n\n\ndef dispatch_bot_command(command, payload):\n\n    if command in COMMANDS:\n\n        COMMANDS[command](payload)\n\n    else:\n\n        bot_say(f\"Unknown command {command}\")\n\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\n\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\n\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "answer_code": "BOT_COMMANDS = {\n    '!hello': bot_hello,\n    '!shout': bot_shout,\n    '!divide': bot_divide,\n    '!count': bot_count,\n    '!topic': bot_topic,\n}\n\ndef dispatch_bot_command(command, payload):\n    if command in BOT_COMMANDS:\n        function = BOT_COMMANDS[command]\n        function(payload)\n    else:\n        bot_say(f'Unknown command: {command}')\n\ndispatch_bot_command('!topic', ['5'])",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Function uses the dictionary to look up the function object associated with a command name",
        "rationale": "The code snippet correctly defines a dictionary constant associating command names with function objects and uses this dictionary to look up the function object associated with a command name. It also handles unknown commands appropriately by outputting a message. The function `dispatch_bot_command` works as expected.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "def bot_divide(payload):\n\n  # Implement the body of the bot_divide() function here.\n\n  bot_say(f\"{payload[0]} \/ {payload[1]} = {float(payload[0]) \/ float(payload[1]):.4f}\")\n\n\n\n\n\nbot_divide(['1.5', '5'])        #=> Chatbot: 1.5 \/ 5 = 0.3000\n\nbot_divide(['10.00', '2'])      #=> Chatbot: 10.00 \/ 2 = 5.0000\n\nbot_divide(['3', '7.0'])        #=> Chatbot: 3 \/ 7.0 = 0.4286\n\nbot_divide([\"49.67\", \"7.782\"])  #=> Chatbot: 49.67 \/ 7.782 = 6.3827",
        "answer_code": "def bot_divide(payload):\n    numerator = float(payload[0])\n    denominator = float(payload[1])\n    bot_say(f'{payload[0]} \/ {payload[1]} = {numerator \/ denominator:.4f}')\n\nbot_divide(['1.5', '5'])",
        "question_text": "### Task 3: Chatbot !divide command (10 marks)\n\nYou will now implement the behaviour for a `!divide` chatbot command. For this command, you may assume that the user always provides two numbers, for example `!divide 1.5 5`. Like the previous task, you only need to define the function and we will worry about accepting user input later.\n\n_Hint: The `payload` argument for all of the chatbot commands will always be a list of strings. For the `bot_divide()` function specifically, the first element of this list will be the numerator (as a string) and the second element will be the denominator (as a string). In order to perform division, you will need to convert these elements to another type._\n\nWhen it comes to displaying the result, the chatbot must **show the full equation** with the answer inside it, not just the answer. The numerator and denominator must be displayed exactly as the user typed them, and the answer must be displayed to 4 decimal places. So, if the user wants to divide `10.00` by `2`, then the full chatbot output should be `10.00 \/ 2 = 5.0000`.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_divide(['1.5', '5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1.5 \/ 5 = 0.3000\n<\/font>\n\n```python\nbot_divide(['10.00', '2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10.00 \/ 2 = 5.0000\n<\/font>\n\n```python\nbot_divide(['3', '7.0'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;3 \/ 7.0 = 0.4286\n<\/font>\n\n#### Criteria\n\n- Uses data from the payload to determine the numerator and denominator of the division. (3 marks)\n- Performs division using an appropriate expression. (1 mark)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Displays the result as an equation using the `bot_say()` function. (2 marks)\n- Displays the numerator and denominator in the output exactly as the user typed them, but the answer to 4 decimal places (see examples). (2 marks)",
        "subquestion": "Performs division using an appropriate expression",
        "rationale": "In this case, the code snippet correctly performs division using an appropriate expression by converting the numerator and denominator to floats and then dividing them. The output also displays the full equation with the answer to 4 decimal places, as required.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Write your bot_count() function here.\n\ndef bot_count (payload):\n\n  if len(payload)==1:\n\n      start_count=1\n\n      end_count=int(payload[0])\n\n  #if the user enter two number.\n\n  else:\n\n      start_count=int(payload[0])\n\n      end_count=start_count+ int(payload[1])\n\n  for python in range(start_count,end_count+1):\n\n    #how it will work\n\n       bot_say(python)\n\n\n\n\n\n\n\nbot_count(['10', '3'])  #=> Chatbot: 10, Chatbot: 11, Chatbot: 12\n\nbot_count(['2'])        #=> Chatbot: 1, Chatbot: 2",
        "answer_code": "def bot_count(payload):\n    if len(payload) == 1:\n        from_number = 1\n        stop = int(payload[0]) + from_number\n    else:\n        from_number = int(payload[0])\n        stop = int(payload[1]) + from_number\n    for i in range(from_number, stop):\n        bot_say(i)\n\nbot_count(['10', '3'])\nbot_count(['2'])",
        "question_text": "### Task 4: Chatbot !count command (12 marks)\n\nImplement the behaviour for a `!count` chatbot command. Like `!divide`, you may assume that the user always provides two numbers. However, in this case they will also be whole numbers. The first of these numbers represents the value to start counting from. The second number represents how many times to count. The bot always counts by ones in ascending order (e.g. 2, 3, 4, 5 when starting at 2 and counting 4 times).\n\nIf the payload contains only one number, that number represents how many times to count and the bot should count up from 1. I recommend solving the task without this feature first, and then adding it afterwards.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_count(['10', '3'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;11\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;12\n<\/font>\n\n```python\nbot_count(['2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;2\n<\/font>\n\n#### Criteria\n\n- Correct function definition. (2 marks)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Uses a loop to repeatedly call `bot_say()`. (2 marks)\n- The loop repeats the correct number of times. (2 marks)\n- The correct numbers are displayed, with one number per chatbot message. (2 marks)\n- The bot correctly counts up from one when only a single value is provided in the payload. (2 marks)",
        "subquestion": "The loop repeats the correct number of times",
        "rationale": "The code snippet correctly implements the behavior for the `!count` chatbot command and repeats the loop the correct number of times.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "\n\nimport random\n\n\n\ntopic_names = [\n\n    \"Algorithms and Flowcharts\",\n\n    \"Statements and expressions\",\n\n    \"Booleans and conditional execution\",\n\n    \"Iteration\",\n\n    \"Functions and objects\",\n\n    \"Strings and files\",\n\n    \"Data Structures\",\n\n    \"Software errors\",\n\n    \"Using modules\",\n\n    \"Structuring and Documenting Code\",\n\n    \"Algorithm design strategies\",\n\n    \"Revision\"\n\n]\n\n\n\n\n\ndef bot_topic(payload):\n\n    if not payload:\n\n        topic_number = random.randint(1, 12)\n\n    else:\n\n        topic_number = int(payload[0])\n\n    topic_name = topic_names[topic_number - 1]\n\n    bot_say(f\"Topic {topic_number}: {topic_name}\")\n\n\n\ndef bot_hello(payload):\n\n    bot_say('Hello world!')\n\n\n\ndef bot_shout(payload):\n\n    payload = ' '.join(payload)\n\n    payload = payload.upper()\n\n    bot_say(f'Chatbot: {payload}')\n\n\n\ndef bot_divide(payload):\n\n    num1 = float(payload[0])\n\n    num2 = float(payload[1])\n\n    total = round(num1 \/ num2, 4)\n\n    return f'{num1}\/{num2} = {total:.4f}'\n\n\n\ndef bot_count(payload):\n\n    start = int(payload[0])\n\n    if len(payload) == 1:\n\n        count = start\n\n        start = 1\n\n    else:\n\n        count = int(payload[1])\n\n    for i in range(start, start + count):\n\n        bot_say(f\"\\n{i}\")\n\n\n\n\n\ndef bot_quit(payload):\n\n    bot_say('Goodbye!')\n\n\n\n\n\n\n\nCOMMANDS = {\n\n    '!hello': bot_hello,\n\n    '!topic': bot_topic,\n\n    '!shout': bot_shout,\n\n    '!divide': bot_divide,\n\n    '!count': bot_count,\n\n    '!quit': bot_quit\n\n}\n\n\n\n\n\ndef dispatch_bot_command(command, payload):\n\n    if command in COMMANDS:\n\n        COMMANDS[command](payload)\n\n    else:\n\n        bot_say(f\"Unknown command {command}\")\n\n\n\nwhile True:\n\n    user_input = chat_input()\n\n    input_split = user_input.split()\n\n\n\n    if not input_split:\n\n        continue\n\n\n\n    command = input_split[0].lower()\n\n    if command[0] == '!':\n\n        if command == '!quit':\n\n            bot_quit([])\n\n            break\n\n        else:\n\n            payload = input_split[1:]\n\n            dispatch_bot_command(command, payload)\n\n    else:\n\n        bot_say(\"Invalid input. Commands should start with '!'\")",
        "answer_code": "while True:\n    line = chat_input()\n    words = line.split(' ')\n    if len(words) == 0:\n        continue\n    command = words[0].lower()\n    if command[0] == '!':\n        if command == '!quit':\n            break\n        payload = words[1:]\n        dispatch_bot_command(command, payload)",
        "question_text": "### Task 7: Interactive chat loop (20 marks)\n\nImplement an interactive loop which repeatedly asks for chat input, with the chatbot processing commands when appropriate. Your code should match the logic of the flowchart shown below:\n\n\nInstead of using the `input()` function to ask for user input, you should use the `chat_input()` function which has been defined for you already. This will result in a nicer looking chat log with colours. Here's an example of how to accept a line of input using this function:\n\n```python\nline = chat_input()\n```\n\nTo split the line into a list of individual words, use the `split()` string method. Here's an example:\n\n```python\n>>> 'These are words'.split(' ')\n['These', 'are', 'words']\n```\n\n_Note: If you run the code and it displays \"You:\" in blue text but no input text box appears, stop the code execution by clicking the stop symbol at the top-left of the cell and try running it again._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n##### Example 1\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#000080\"><b>You:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;I'm here!\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#000080\"><b>You:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;!shout hooray\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;HOORAY\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#000080\"><b>You:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;!quit\n<\/font>\n\n##### Example 2\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#000080\"><b>You:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;!HELLO\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#000080\"><b>You:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;!QUIT\n<\/font>\n\n#### Criteria\n\n- Repeatedly asks for user input using `chat_input()`. (4 marks)\n- Case insensitive command recognition. (2 marks)\n- Finishes gracefully on `!quit` command. (4 marks)\n- Uses the `dispatch_bot_command()` function to dispatch other commands. (4 marks)\n- Program behaviour otherwise matches the flowchart. (6 marks)",
        "subquestion": "Finishes gracefully on !quit command",
        "rationale": "produce the student_mark_out_of_10. We need to evaluate how well the code snippet finishes gracefully on the `!quit` command. The code snippet correctly implements the `bot_quit` function to handle the `!quit` command and display a goodbye message. This ensures that the program exits gracefully when the user inputs `!quit`.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Add your import statement here.\n\nimport random\n\n#list constant containg the names of the 12 topics\n\nTOPICS = [\n\n    \"Algorithms and Flowcharts\",\n\n    \"Statements and Expressions\",\n\n    \"Booleans and Conditional Execution\",\n\n    \"Iteration\",\n\n    \"Functions and Objects\",\n\n    \"Strings and Files\",\n\n    \"Data Structures\",\n\n    \"Software Errors\",\n\n    \"Using Modules\",\n\n    \"Structuring and Documenting Code\",\n\n    \"Algorithm Design Strategies\",\n\n    \"Revison\"\n\n    ]\n\n\n\ndef bot_topic (payload):\n\n\n\n    if not payload:\n\n       topic_number = random.randint(1, 12)\n\n\n\n    else:\n\n       topic_number = int(payload[0])\n\n\n\n    topic_name = TOPICS[topic_number - 1]\n\n\n\n    bot_say(f\"Topic {topic_number} : {topic_name}\")\n\n\n\nbot_topic(['1'])  #=> Chatbot: Topic 1: Algorithms and Flowcharts\n\nbot_topic(['9'])     #=> Random. For example, Chatbot: Topic 7: Data Structures",
        "answer_code": "import random\n\nTOPICS = [\n    'Algorithms and Flowcharts',\n    'Statements and Expressions',\n    'Booleans and Conditional Execution',\n    'Iteration',\n    'Functions and Objects',\n    'Strings and Files',\n    'Data Structures',\n    'Software Errors',\n    'Using Modules',\n    'Structuring and Documenting Code',\n    'Algorithm Design Strategies',\n    'Revision',\n]\n\ndef bot_topic(payload):\n    if len(payload) > 0:\n        number = int(payload[0])\n    else:\n        number = random.randint(1, 12)\n    topic_name = TOPICS[number - 1]\n    bot_say(f'Topic {number}: {topic_name}')\n\nbot_topic([])\nbot_topic(['1'])",
        "question_text": "### Task 5: Chatbot !topic command (15 marks)\n\nImplement behaviour for a `!topic` command which displays the name of one of the twelve topics in CSE1PE\/PES.\n\nYou can find the topic names by referring to the Subject Learning Guide or the weekly sections on LMS. For example, the name of topic 1 is \"Algorithms and Flowcharts\". You will need to define a list constant which contains all of the topic names in order. You are _not_ to include the word \"Topic\" or the topic numbers in the list (i.e. do not put \"Topic 1: Algorithms and Flowcharts\" in the list, put \"Algorithms and Flowcharts\" instead). The topic number should be added dynamically by the program instead (per the flowchart).\n\nThe behaviour of the `!topic` command is described in the flowchart below. Your solution should implement this algorithm as closely as possible.\n\n\nNote that one of the steps the flowchart involves generating a random number. You must import and make use of the `random` module from the Python Standard Library to do this. Consult [the documentation for the `random` module](https:\/\/docs.python.org\/3\/library\/random.html) and select an appropriate function to use for this part of your solution. For information about importing modules, refer to Topic 9.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_topic(['1'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 1: Algorithms and Flowcharts\n<\/font>\n\n```python\nbot_topic([])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 7: Data Structures\n<\/font>\n\n(Note: for this last example the selected topic is meant to be random, so your code should display different topics across different runs).\n\n#### Criteria\n\n- Correct definition of the list constant. (4 marks)\n- Correct function definition. (2 marks)\n- Generates a random number in the correct range using the `random` module. (3 marks)\n- Indexes the list constant correctly to get the topic name. (2 marks)\n- Program behaviour otherwise matches the flowchart. (4 marks)\n\n#### Your Solution\n\n# Add your import statement here.\n\n# Define your constant here.\n\n# Write your bot_topic() function here.\n\n\nbot_topic(['1'])  #=> Chatbot: Topic 1: Algorithms and Flowcharts\nbot_topic([])     #=> Random. For example, Chatbot: Topic 7: Data Structures",
        "subquestion": "Program behaviour otherwise matches the flowchart",
        "rationale": "produce the student_mark_out_of_10. We need to first check if the code correctly defines the list constant, which it does. Next, we need to verify if the function definition is correct, which it is. Then, we need to ensure that the code generates a random number in the correct range using the `random` module, which it does. After that, we need to confirm if the code indexes the list constant correctly to get the topic name, which it does. Finally, we need to check if the program behavior otherwise matches the flowchart, which it does based on the provided examples. Therefore, the code snippet aligns with the flowchart and meets the criteria outlined in the question.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "commands = {\n\n    '!shout': bot_shout,\n\n    '!divide': bot_divide,\n\n    '!count': bot_count,\n\n    '!topic': bot_topic,\n\n    '!hello': bot_hello}\n\n\n\n\n\ndef dispatch_bot_command(command, payload):\n\n    if command in commands:\n\n        my_function = commands[command]\n\n        my_function(payload)\n\n    else:\n\n        bot_say(f'Unknown command {command}')\n\n\n\ndispatch_bot_command('!hello', [])\n\ndispatch_bot_command('!topic', ['5'])\n\ndispatch_bot_command('!fake', [])",
        "answer_code": "BOT_COMMANDS = {\n    '!hello': bot_hello,\n    '!shout': bot_shout,\n    '!divide': bot_divide,\n    '!count': bot_count,\n    '!topic': bot_topic,\n}\n\ndef dispatch_bot_command(command, payload):\n    if command in BOT_COMMANDS:\n        function = BOT_COMMANDS[command]\n        function(payload)\n    else:\n        bot_say(f'Unknown command: {command}')\n\ndispatch_bot_command('!topic', ['5'])",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Function uses the dictionary to look up the function object associated with a command name",
        "rationale": "In this case, the code snippet correctly defines a dictionary of bot commands and a function to dispatch commands based on the input command name. The function uses the dictionary to look up the function object associated with the command name and calls it if it exists, otherwise, it outputs a message for unknown commands.\n\nThe code snippet provided meets the requirements of the subquestion aspect by correctly using the dictionary to look up the function object associated with the command name.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Write your solution here.\n\n\n\n\n\ncommands = {'!hello': bot_hello, '!shout': bot_shout, '!divide': bot_divide, '!count': bot_count, '!topic': bot_topic}\n\n\n\n\n\ndef dispatch_bot_command(name, payload):\n\n\n\n    if name in commands:\n\n        commands[name](payload)\n\n\n\n    else:\n\n        fake = \"Unknown command \" + str(name)\n\n        bot_say(fake)\n\n\n\n\n\n    pass\n\n\n\n\n\n\n\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\n\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\n\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "answer_code": "BOT_COMMANDS = {\n    '!hello': bot_hello,\n    '!shout': bot_shout,\n    '!divide': bot_divide,\n    '!count': bot_count,\n    '!topic': bot_topic,\n}\n\ndef dispatch_bot_command(command, payload):\n    if command in BOT_COMMANDS:\n        function = BOT_COMMANDS[command]\n        function(payload)\n    else:\n        bot_say(f'Unknown command: {command}')\n\ndispatch_bot_command('!topic', ['5'])",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Correct function behaviour",
        "rationale": "produce the student_mark_out_of_10. We first check if the command is in the dictionary of bot commands. If it is, we call the associated function. If not, we output \"Unknown command\" followed by the unrecognized command name. The code snippet provided correctly defines the dictionary constant, defines the dispatch_bot_command function with the correct parameters, and implements the correct behavior of calling the associated function or outputting \"Unknown command\" as expected.",
        "student_mark_out_of_10": "10"
      }
    ],
    "signature_instructions": "Grade a code snippet according to how well it answers a question and subquestion aspect on a scale of 0-10. Use the gold standard to guide your grading. ",
    "signature_prefix": "Student Mark Out Of 10:",
    "extended_signature_instructions": "Grade a code snippet according to how well it answers a question and subquestion aspect on a scale of 0-10. Use the gold standard to guide your grading.",
    "extended_signature_prefix": "Student Mark Out Of 10:"
  }
}