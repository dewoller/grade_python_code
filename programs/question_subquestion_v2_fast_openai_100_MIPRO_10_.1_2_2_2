{
  "prog": {
    "lm": null,
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "code": "# Write your solution here.\n\ndictionary={'!hello': bot_hello,'!shout': bot_shout,'!divide': bot_divide,'!count': bot_count,'!topic': bot_topic}\n\ndef dispatch_bot_command(name,payload):\n\n    if name in dictionary.keys():\n\n      a=dictionary[name]\n\n      a(payload)\n\n    else:\n\n      bot_say('Unknown command '+name)\n\n\n\n\n\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\n\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\n\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Function uses the dictionary to look up the function object associated with a command name",
        "rationale": "In this code snippet, the `dispatch_bot_command` function correctly uses the dictionary to look up the function object associated with a command name. It checks if the command is in the dictionary and calls the associated function if it is, otherwise it outputs \"Unknown command\" followed by the unrecognized command.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "def bot_count(payload):\n\n    # Convert elements in the payload to appropriate types\n\n    start = 1 if len(payload) == 1 else int(payload[0])\n\n    count = int(payload[0]) if len(payload) == 1 else int(payload[1])\n\n\n\n    # Use a loop to repeatedly call bot_say()\n\n    for i in range(start, start + count):\n\n        # Display the current number using bot_say()\n\n        bot_say(i)\n\n\n\n# Test calls\n\nbot_count(['10', '3'])  #=> Chatbot: 10, Chatbot: 11, Chatbot: 12\n\nprint(\"NEXT\")\n\nbot_count(['2'])        #=> Chatbot: 1, Chatbot: 2\n\nprint(\"NEXT\")\n\nbot_count(['5'])        #=> Chatbot: 1, Chatbot: 2, Chatbot: 3, Chatbot: 4, Chatbot: 5\n\n\n",
        "question_text": "### Task 4: Chatbot !count command (12 marks)\n\nImplement the behaviour for a `!count` chatbot command. Like `!divide`, you may assume that the user always provides two numbers. However, in this case they will also be whole numbers. The first of these numbers represents the value to start counting from. The second number represents how many times to count. The bot always counts by ones in ascending order (e.g. 2, 3, 4, 5 when starting at 2 and counting 4 times).\n\nIf the payload contains only one number, that number represents how many times to count and the bot should count up from 1. I recommend solving the task without this feature first, and then adding it afterwards.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_count(['10', '3'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;11\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;12\n<\/font>\n\n```python\nbot_count(['2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;2\n<\/font>\n\n#### Criteria\n\n- Correct function definition. (2 marks)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Uses a loop to repeatedly call `bot_say()`. (2 marks)\n- The loop repeats the correct number of times. (2 marks)\n- The correct numbers are displayed, with one number per chatbot message. (2 marks)\n- The bot correctly counts up from one when only a single value is provided in the payload. (2 marks)",
        "subquestion": "The bot correctly counts up from one when only a single value is provided in the payload",
        "rationale": "produce the student_mark_out_of_10. We first need to check if the payload contains only one number. If it does, the bot should start counting from 1. The code snippet correctly handles this scenario by setting the start variable to 1 when the length of the payload is 1. It then uses a loop to count up from the start value. The bot_say() function is called for each number in the correct order. Therefore, the code snippet effectively implements the behavior of counting up from 1 when only a single value is provided in the payload.",
        "student_mark_out_of_10": "10"
      }
    ],
    "signature_instructions": "Grade a code snippet according to how well it answers a question and subquestion aspect on a scale of 0-10",
    "signature_prefix": "Student Mark Out Of 10:",
    "extended_signature_instructions": "Evaluate the provided code snippet based on its accuracy in implementing the chatbot command functionalities and adhering to the specified criteria.",
    "extended_signature_prefix": "`Code Evaluation:`"
  }
}