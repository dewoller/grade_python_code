{
  "prog": {
    "lm": null,
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "code": "# Write your solution here.\n\ndictionary={'!hello': bot_hello,'!shout': bot_shout,'!divide': bot_divide,'!count': bot_count,'!topic': bot_topic}\n\ndef dispatch_bot_command(name,payload):\n\n    if name in dictionary.keys():\n\n      a=dictionary[name]\n\n      a(payload)\n\n    else:\n\n      bot_say('Unknown command '+name)\n\n\n\n\n\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\n\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\n\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "answer_code": "BOT_COMMANDS = {\n    '!hello': bot_hello,\n    '!shout': bot_shout,\n    '!divide': bot_divide,\n    '!count': bot_count,\n    '!topic': bot_topic,\n}\n\ndef dispatch_bot_command(command, payload):\n    if command in BOT_COMMANDS:\n        function = BOT_COMMANDS[command]\n        function(payload)\n    else:\n        bot_say(f'Unknown command: {command}')\n\ndispatch_bot_command('!topic', ['5'])",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Function uses the dictionary to look up the function object associated with a command name",
        "rationale": "In this case, the code snippet correctly defines a dictionary associating command names with function objects and uses this dictionary to look up the function object associated with a command name. It then calls the function if it exists in the dictionary. The code snippet also handles the case where the command is not recognized by the bot. Overall, the code snippet addresses the subquestion aspect effectively.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "def bot_count(payload):\n\n    # Convert elements in the payload to appropriate types\n\n    start = 1 if len(payload) == 1 else int(payload[0])\n\n    count = int(payload[0]) if len(payload) == 1 else int(payload[1])\n\n\n\n    # Use a loop to repeatedly call bot_say()\n\n    for i in range(start, start + count):\n\n        # Display the current number using bot_say()\n\n        bot_say(i)\n\n\n\n# Test calls\n\nbot_count(['10', '3'])  #=> Chatbot: 10, Chatbot: 11, Chatbot: 12\n\nprint(\"NEXT\")\n\nbot_count(['2'])        #=> Chatbot: 1, Chatbot: 2\n\nprint(\"NEXT\")\n\nbot_count(['5'])        #=> Chatbot: 1, Chatbot: 2, Chatbot: 3, Chatbot: 4, Chatbot: 5\n\n\n",
        "answer_code": "def bot_count(payload):\n    if len(payload) == 1:\n        from_number = 1\n        stop = int(payload[0]) + from_number\n    else:\n        from_number = int(payload[0])\n        stop = int(payload[1]) + from_number\n    for i in range(from_number, stop):\n        bot_say(i)\n\nbot_count(['10', '3'])\nbot_count(['2'])",
        "question_text": "### Task 4: Chatbot !count command (12 marks)\n\nImplement the behaviour for a `!count` chatbot command. Like `!divide`, you may assume that the user always provides two numbers. However, in this case they will also be whole numbers. The first of these numbers represents the value to start counting from. The second number represents how many times to count. The bot always counts by ones in ascending order (e.g. 2, 3, 4, 5 when starting at 2 and counting 4 times).\n\nIf the payload contains only one number, that number represents how many times to count and the bot should count up from 1. I recommend solving the task without this feature first, and then adding it afterwards.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_count(['10', '3'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;11\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;12\n<\/font>\n\n```python\nbot_count(['2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;2\n<\/font>\n\n#### Criteria\n\n- Correct function definition. (2 marks)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Uses a loop to repeatedly call `bot_say()`. (2 marks)\n- The loop repeats the correct number of times. (2 marks)\n- The correct numbers are displayed, with one number per chatbot message. (2 marks)\n- The bot correctly counts up from one when only a single value is provided in the payload. (2 marks)",
        "subquestion": "The bot correctly counts up from one when only a single value is provided in the payload",
        "rationale": "produce the student_mark_out_of_10. We first check if the length of the payload is 1, if so, we set the starting number to 1. Then, we correctly calculate the count based on the payload. Next, we use a loop to call bot_say() the correct number of times starting from the correct number. Finally, we test the function with the provided examples and additional cases to ensure it counts up from 1 when only a single value is provided.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Write your bot_count() function here.\n\ndef bot_count(payload):\n\n  if len(payload) == 1:\n\n    start = 1\n\n    count = int(payload[0])\n\n  else:\n\n    start = int(payload[0])\n\n    count = int(payload[1])\n\n  for i in range(start, start + count):\n\n    bot_say(str(i))\n\n\n\n\n\nbot_count(['10', '3'])  #=> Chatbot: 10, Chatbot: 11, Chatbot: 12\n\nbot_count(['2'])        #=> Chatbot: 1, Chatbot: 2",
        "answer_code": "def bot_count(payload):\n    if len(payload) == 1:\n        from_number = 1\n        stop = int(payload[0]) + from_number\n    else:\n        from_number = int(payload[0])\n        stop = int(payload[1]) + from_number\n    for i in range(from_number, stop):\n        bot_say(i)\n\nbot_count(['10', '3'])\nbot_count(['2'])",
        "question_text": "### Task 4: Chatbot !count command (12 marks)\n\nImplement the behaviour for a `!count` chatbot command. Like `!divide`, you may assume that the user always provides two numbers. However, in this case they will also be whole numbers. The first of these numbers represents the value to start counting from. The second number represents how many times to count. The bot always counts by ones in ascending order (e.g. 2, 3, 4, 5 when starting at 2 and counting 4 times).\n\nIf the payload contains only one number, that number represents how many times to count and the bot should count up from 1. I recommend solving the task without this feature first, and then adding it afterwards.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_count(['10', '3'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;11\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;12\n<\/font>\n\n```python\nbot_count(['2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1\n<br\/>&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;2\n<\/font>\n\n#### Criteria\n\n- Correct function definition. (2 marks)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Uses a loop to repeatedly call `bot_say()`. (2 marks)\n- The loop repeats the correct number of times. (2 marks)\n- The correct numbers are displayed, with one number per chatbot message. (2 marks)\n- The bot correctly counts up from one when only a single value is provided in the payload. (2 marks)",
        "subquestion": "The correct numbers are displayed, with one number per chatbot message",
        "rationale": "The code snippet correctly displays the correct numbers with one number per chatbot message. It iterates through the range of numbers and calls `bot_say()` for each number.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "# Write your solution here.\n\nCOMMANDS = {\n\n    '!hello': bot_hello,\n\n    '!shout': bot_shout,\n\n    '!divide': bot_divide,\n\n    '!count': bot_count,\n\n    '!topic': bot_topic\n\n}\n\n\n\ndef dispatch_bot_command(command, payload):\n\n    if command in COMMANDS:\n\n        COMMANDS[command](payload)\n\n    else:\n\n        bot_say(f\"Unknown command {command}\")\n\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\n\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\n\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "answer_code": "BOT_COMMANDS = {\n    '!hello': bot_hello,\n    '!shout': bot_shout,\n    '!divide': bot_divide,\n    '!count': bot_count,\n    '!topic': bot_topic,\n}\n\ndef dispatch_bot_command(command, payload):\n    if command in BOT_COMMANDS:\n        function = BOT_COMMANDS[command]\n        function(payload)\n    else:\n        bot_say(f'Unknown command: {command}')\n\ndispatch_bot_command('!topic', ['5'])",
        "question_text": "### Task 6: Chatbot command processor (15 marks)\n\nNow that we have a few different chatbot command behaviours implemented, let's start tying everything together. We will do this in two parts. In this task, we will write a function which *dispatches* commands. That is, it looks at a command and determines which bot function to call. In the next task, we will use this function to build a simple simulated chat system with user input.\n\nFirstly, create a dictionary constant which associates command names (strings) with function objects (command behaviours). For example, the key\/value for the hello command should be `'!hello': bot_hello`. Importantly, the value should be the function name only (no brackets afterwards), otherwise Python will attempt to call the function during definition of the dictionary. There should be five commands in total from previous tasks.\n\nNext, define a function called `dispatch_bot_command`. This function should have two parameters: the first is the name of the command (e.g. `\"!shout\"`), and the second is the payload (e.g. `[\"i\", \"love\", \"python\"]`). The code inside the function should check whether the command is in the dictionary constant. If it is, it should call the associated function. If it is not, the bot should say \"Unknown command\" and the name of the unrecognised command.\n\n_Hint: A function can be stored in a variable (or dictionary) just like any other kind of object, and can be called using that variable name instead of the function name. So if you retrieve a function from a dictionary and store it in a variable called `my_function`, you can call it using `my_function(...)`._\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\ndispatch_bot_command('!hello', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Hello world!\n<\/font>\n\n```python\ndispatch_bot_command('!topic', ['5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Topic 5: Functions and Objects\n<\/font>\n\n```python\ndispatch_bot_command('!fake', [])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;Unknown command !fake\n<\/font>\n\n#### Criteria\n\n- Correct definition of the dictionary constant. (5 marks)\n- Correct function definition. (2 marks)\n- Correct function behaviour. (4 marks)\n- Function uses the dictionary to look up the function object associated with a command name. (2 marks)\n- Appropriate output is produced for unknown commands. (2 marks)\n\n#### Your Solution\n\n# Write your solution here.\n\n\ndispatch_bot_command('!hello', [])     #=> Chatbot: Hello world!\ndispatch_bot_command('!topic', ['5'])  #=> Chatbot: Topic 5: Functions and Objects\ndispatch_bot_command('!fake', [])      #=> Chatbot: Unknown command !fake",
        "subquestion": "Function uses the dictionary to look up the function object associated with a command name",
        "rationale": "The code snippet correctly defines a dictionary constant associating command names with function objects and uses this dictionary to look up the function object associated with a command name. It also handles unknown commands appropriately by outputting a message. The function `dispatch_bot_command` works as expected.",
        "student_mark_out_of_10": "10"
      },
      {
        "augmented": true,
        "code": "def bot_divide(payload):\n\n  # Implement the body of the bot_divide() function here.\n\n  bot_say(f\"{payload[0]} \/ {payload[1]} = {float(payload[0]) \/ float(payload[1]):.4f}\")\n\n\n\n\n\nbot_divide(['1.5', '5'])        #=> Chatbot: 1.5 \/ 5 = 0.3000\n\nbot_divide(['10.00', '2'])      #=> Chatbot: 10.00 \/ 2 = 5.0000\n\nbot_divide(['3', '7.0'])        #=> Chatbot: 3 \/ 7.0 = 0.4286\n\nbot_divide([\"49.67\", \"7.782\"])  #=> Chatbot: 49.67 \/ 7.782 = 6.3827",
        "answer_code": "def bot_divide(payload):\n    numerator = float(payload[0])\n    denominator = float(payload[1])\n    bot_say(f'{payload[0]} \/ {payload[1]} = {numerator \/ denominator:.4f}')\n\nbot_divide(['1.5', '5'])",
        "question_text": "### Task 3: Chatbot !divide command (10 marks)\n\nYou will now implement the behaviour for a `!divide` chatbot command. For this command, you may assume that the user always provides two numbers, for example `!divide 1.5 5`. Like the previous task, you only need to define the function and we will worry about accepting user input later.\n\n_Hint: The `payload` argument for all of the chatbot commands will always be a list of strings. For the `bot_divide()` function specifically, the first element of this list will be the numerator (as a string) and the second element will be the denominator (as a string). In order to perform division, you will need to convert these elements to another type._\n\nWhen it comes to displaying the result, the chatbot must **show the full equation** with the answer inside it, not just the answer. The numerator and denominator must be displayed exactly as the user typed them, and the answer must be displayed to 4 decimal places. So, if the user wants to divide `10.00` by `2`, then the full chatbot output should be `10.00 \/ 2 = 5.0000`.\n\n#### Examples for testing\n\nUse the examples below, as well as your own examples, to test your code. The output from your chatbot should exactly match what is shown here.\n\n```python\nbot_divide(['1.5', '5'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;1.5 \/ 5 = 0.3000\n<\/font>\n\n```python\nbot_divide(['10.00', '2'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;10.00 \/ 2 = 5.0000\n<\/font>\n\n```python\nbot_divide(['3', '7.0'])\n```\n\n<font face=\"monospace\">\n&nbsp;&nbsp;&nbsp;<font color=\"#800000\"><b>Chatbot:<\/b><\/font>\n<br\/>&nbsp;&nbsp;&nbsp;3 \/ 7.0 = 0.4286\n<\/font>\n\n#### Criteria\n\n- Uses data from the payload to determine the numerator and denominator of the division. (3 marks)\n- Performs division using an appropriate expression. (1 mark)\n- Converts elements in the payload to an appropriate type. (2 marks)\n- Displays the result as an equation using the `bot_say()` function. (2 marks)\n- Displays the numerator and denominator in the output exactly as the user typed them, but the answer to 4 decimal places (see examples). (2 marks)",
        "subquestion": "Performs division using an appropriate expression",
        "rationale": "In this case, the code snippet correctly performs division using an appropriate expression by converting the numerator and denominator to floats and then dividing them. The output also displays the full equation with the answer to 4 decimal places, as required.",
        "student_mark_out_of_10": "10"
      }
    ],
    "signature_instructions": "Grade a code snippet according to how well it answers a question and subquestion aspect on a scale of 0-10. Use the gold standard to guide your grading. ",
    "signature_prefix": "Student Mark Out Of 10:",
    "extended_signature_instructions": "Grade a code snippet according to how well it answers a question and subquestion aspect on a scale of 0-10. Use the gold standard to guide your grading.",
    "extended_signature_prefix": "Student Mark Out Of 10:"
  }
}